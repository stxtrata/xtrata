xStrata Inscription Protocol

Contract: u64bxr-v9.2.14
Standard: SIP-009 (NFT-compatible)
Network: Stacks (Bitcoin L2)
Status: Deployed (legacy / pre-final)

Overview

xStrata v9.2.14 is an on-chain inscription and data-layer protocol built on Stacks.
It allows users to inscribe large datasets by uploading content in chunks, sealing them into SIP-009-compatible NFTs, and optionally linking inscriptions together via on-chain dependencies.

This version represents an important compatibility and stabilisation milestone, focused on:

SIP-009 wallet/indexer compatibility

Safe token URI handling

On-chain SVG access helpers

Chunked data uploads with hash verification

Later versions (≥ v9.2.17) refine semantics around immutability, resumability, and governance. This README documents v9.2.14 as deployed, without retroactive guarantees.

Key Design Goals of v9.2.14

Wallet / indexer compatibility

Implements the SIP-009 NFT trait

Uses standard function signatures

Returns token URIs compatible with existing NFT tooling

Safe token-uri usage

Token URI is a short ASCII string (≤256 chars)

Intended to point to JSON metadata (off-chain or on-chain)

Avoids inline SVG or # fragment issues

On-chain SVG availability

SVG is stored on-chain as a static constant

Exposed via read-only helper functions

Base64-encoded data URI avoids parsing pitfalls

Chunked uploads

Large data is split into fixed-size chunks (16KB max)

Uploaded incrementally with a running hash

Final seal verifies content integrity

High-Level Architecture
NFT Layer

Each sealed inscription is minted as a SIP-009 NFT

Token IDs are sequential (uint)

Ownership is transferable

Token URI is stored explicitly per ID

Upload Layer

Uploads are session-based

Session key: { uploader, expected-hash }

State tracks:

MIME type

total size

total chunks

current chunk index

running hash

Data Layer

Chunks are stored on-chain:

{ context = file-hash, index } → data


Data is verified incrementally using SHA-256

Dependency Layer

Inscriptions may reference up to 50 other inscription IDs

Dependencies are stored on-chain

No validation of dependency existence is performed in this version

Inscription Lifecycle (v9.2.14)
1. Begin Inscription
(begin-inscription expected-hash mime-type total-size total-chunks)


Creates a new upload session

Fails if a session with the same {uploader, hash} already exists

Charges a fixed begin royalty

Upload sessions are not resumable in this version

⚠️ If an upload is interrupted, the user must start over with a new hash.

2. Upload Chunk Batches
(add-chunk-batch hash (list-of-chunks))


Uploads up to 50 chunks per call

Chunks are written sequentially

Running hash is updated with:

sha256(previous-hash || chunk-data)


Important notes (v9.2.14):

No enforcement that all declared chunks are uploaded before sealing

No protection against chunk overwrites by different users using the same hash

No explicit batch-size validation beyond list size

3. Seal Inscription
(seal-inscription expected-hash token-uri)


Seal process:

Verifies final running hash matches expected hash

Charges seal royalty based on declared chunk count

Mints NFT

Writes metadata

Deletes upload session

Limitations in v9.2.14:

Does not check that current-index == total-chunks

Relies on user honesty for completeness

Token URI is accepted as-is (non-empty string only)

4. Recursive Seal (Optional)
(seal-recursive expected-hash token-uri dependencies)


Writes dependencies before sealing

Does not validate whether dependency IDs exist

Dependencies may point to non-existent or future tokens

This behaviour is allowed in v9.2.14 but was later restricted in newer versions.

Fees & Royalties (v9.2.14)

Fees are hard-coded constants in this version.

Constants (microSTX)

ROYALTY-BEGIN: 100,000 (0.1 STX)

ROYALTY-SEAL-BASE: 100,000 (0.1 STX)

ROYALTY-SEAL-PER-CHUNK: 10,000 (0.01 STX per chunk)

Behaviour

Begin inscription charges ROYALTY-BEGIN

Sealing charges:

ROYALTY-SEAL-BASE + (ROYALTY-SEAL-PER-CHUNK × total-chunks)


Fees are paid to royalty-recipient

No admin-adjustable pricing in this version

Admin Capabilities (v9.2.14)

Admin identity:

(define-constant CONTRACT-OWNER tx-sender)


Admin can:

Change royalty recipient

Admin cannot:

Pause the protocol

Adjust fees

Transfer admin ownership

Modify user inscriptions

SIP-009 Interface

Implemented functions:

get-token-uri

get-owner

transfer

get-last-token-id

These allow compatibility with wallets, marketplaces, and indexers.

Read-Only Helpers
Content & Metadata

get-inscription-meta

get-chunk

get-upload-state

get-pending-chunk

get-dependencies

SVG Helpers

get-svg

get-svg-data-uri

SVG helpers are not part of SIP-009, but are provided for custom renderers.

Known Limitations of v9.2.14

This version is intentionally documented with its constraints:

❌ Uploads are not resumable

❌ No enforcement that all chunks are uploaded before seal

❌ Dependencies are not validated

❌ Chunk namespace is not uploader-isolated

❌ Fees are fixed and not governance-adjustable

❌ No pause / safety mechanism

❌ No explicit creator provenance field

❌ Some immutability guarantees are implicit, not enforced

These issues are addressed in later versions.

Relationship to Later Versions

v9.2.14 should be understood as a compatibility-first milestone, not the final semantic model.

Later versions (e.g. v9.2.17) introduce:

resumable uploads

hard completeness checks

immutable creator provenance

dependency validation

fee governance

pause safety

stronger immutability guarantees

This README applies only to v9.2.14.

Intended Use

v9.2.14 inscriptions remain valid and indexable forever.

However:

New applications should prefer newer protocol versions

Indexers should treat v9.2.14 inscriptions as historical artifacts with looser guarantees

Philosophy (v9.2.14)

“Make it compatible first.”

This version prioritised interoperability and safe metadata handling, laying the groundwork for stricter semantics in later releases.