# How to Mint an xStrata Inscription (v9.2.17) — Step by Step

This guide explains the practical flow to upload content in chunks and mint (seal) an xStrata NFT.

---

## Before you start: know the key idea
You will mint using an **expected final hash** (a 32-byte fingerprint of the complete content).

As you upload chunks, the contract calculates a running hash in order and only allows minting if:
- every chunk is uploaded, and
- the contract’s computed final hash equals the expected hash you declared.

This prevents incomplete uploads or content tampering.

---

## Step 0 — Prepare your content and plan chunking

1) Choose your content (image/audio/video/data/etc.)
2) Decide:
   - `mime` (e.g., `image/png`, `audio/wav`, `application/json`)
   - `total-size` (in bytes)
3) Split the content into chunks:
   - each chunk must be **<= 16 KB**
   - total chunks can be any number > 0
   - uploads must happen in order (0, 1, 2, ...)

---

## Step 1 — Compute the expected final hash (off-chain)

You must compute the same hash the contract computes:

- Start with `runningHash = 32 bytes of 0x00`
- For each chunk in order:
  - `runningHash = sha256(runningHash || chunkBytes)`

When finished:
- `expected-hash = runningHash` (32 bytes)

Keep this value safe — it’s the key to the upload session and sealing.

---

## Step 2 — Start (or resume) an upload session

Call:

- `begin-inscription(expected-hash, mime, total-size, total-chunks)`

What happens:
- If this `{you, expected-hash}` has never been used:
  - you pay the “begin” fee once
  - an upload state record is created
- If it already exists:
  - it’s treated as a resume
  - no new begin fee is charged
  - the contract checks you didn’t change the declared parameters

If the contract is paused, you’ll get `ERR-PAUSED`.

---

## Step 3 — Upload the content in batches

Call:

- `add-chunk-batch(expected-hash, chunksBatch)`

Where:
- `chunksBatch` is a list of 1 to 50 chunks
- each chunk is a `buff 16384` (max 16 KB)

Rules to follow:
- batches must be uploaded in order
- the contract tracks your `current-index`
- you cannot upload past `total-chunks`

Tip:
- upload 50 chunks per transaction where possible for efficiency

---

## Step 4 — Check progress (optional but recommended)

You can inspect the upload state at any time:

- `get-upload-state(expected-hash, your-principal)`

This returns (if present):
- current-index (how many chunks the contract has accepted)
- running-hash (current computed fingerprint)
- mime/size/total-chunks as declared

You can also fetch any pending chunk directly:

- `get-pending-chunk(expected-hash, your-principal, chunk-index)`

---

## Step 5 — Seal (mint) the inscription

Once all chunks are uploaded (current-index == total-chunks), mint by sealing.

### Option A: normal seal
Call:

- `seal-inscription(expected-hash, token-uri-string)`

Requirements:
- token URI must be non-empty and <= 256 ASCII chars
- contract must not be paused
- uploaded chunk count must match
- running hash must match expected hash

### Option B: recursive seal (with dependencies)
Call:

- `seal-recursive(expected-hash, token-uri-string, dependencies)`

Where `dependencies` is a list (up to 50) of earlier token IDs.

Important rule:
- dependencies must already exist at seal time (no forward references)

---

## Step 6 — After mint: retrieve and display

Once minted, you can:

### Get the token owner
- `get-owner(token-id)`

### Get the token URI (what wallets/indexers commonly use)
- `get-token-uri(token-id)`

### Get the stored meta record
- `get-inscription-meta(token-id)`

### Reconstruct content from chunks
Fetch chunks 0..N-1:

- `get-chunk(token-id, index)`

The contract addresses sealed chunks by the stored final hash, so `get-chunk` is the safer “post-mint” method.

---

## Optional: abandon an upload session (does not delete chunks)

If you want to delete just the upload session record:

- `abandon-upload(expected-hash)`

Notes:
- This only removes the “session state”
- chunks already uploaded remain stored (not deleted)
- contract must not be paused

---

## Troubleshooting

### “ERR-HASH-MISMATCH”
- Your off-chain hash calculation doesn’t match what was uploaded.
Common causes:
- chunks not identical to what you hashed
- chunk order mismatch
- chunk boundaries differ (different splitting)

### “ERR-INVALID-BATCH”
Common causes:
- batch is empty
- batch has > 50 chunks
- you tried to upload beyond total-chunks
- you resumed with different mime/size/total-chunks values

### “ERR-PAUSED”
Admin has paused inscription writes (uploads/sealing). Transfers and reads still work.

### “ERR-DEPENDENCY-MISSING”
A dependency ID is not considered valid at seal time (e.g., forward reference or non-existent).